이 장의 앞부분에서 블록 스코프를 보았다. 겉으로 보기에는 매우 간단하다.
블록 내에서 let이나 const로 선언된 변수는 블록 내에서만 접근할 수 있다.

- code1.js

블록이 루프에 연결되면 어떻게 될까? 모든 루프 반복이 동일한 변수를 사용할까?
아니면 각 반복마다 별도의 변수가 생성될까? 루프 내에서 생선된 클로저는 어떻게 작동할까?
자바스크립트의 블록 스코프를 설계하는 사람들은 영리한 일을 했다.
각 룰프 반복은 함수에 대한 다른 호출이 각각 고유한 지역 변수를 얻는 것과 거의 똑같은 방식으로 고유한 블록 변수를 얻는다.
즉, 블록 스코프를 사용하여 고전적인 "루프 내 클로저" 문제를 해결할 수 있다.

"루프 내 클로저" 문제

아마도 "루프 내 클로저" 문제에 대해 잘 알고 있을 것이다. code2.js의 코드를 실행하여 이 문제를 확인하자.

- code2.js

(이 문제를 해결하는 데 도움이 될 수 있는 setTimeout의 기능은 무시하자. 이는 비동기 작업의 자리를 표시하는 예일 뿐이다).
코드가 1,2,3을 출력할 것으로 예상했을 텐데 실제로는 4,4,4를 출력한다.
그 이유는 루프가 끌날 때까지 각 타이머가 콜백을 실행하지 않기 때문이다.
콜백을 호출할 때까지 counter의 값은 4이고 var로 선언되었기 때문에 counter는 ClosuresInLoopsPorblem 함수 전체에서 정의된다.
세 타이머 콜백은 모두 동일한 counter 변수를 통해 감싸지므로 모두 값 4를 본다.
ES5와 이전 버전에서 이를 해결하는 일반적인 방법은 다른 함수를 도입하고 counter를 인수로 전달한 다음 console.log에서 counter 대신 해당 인수를 사용하는 것이다.
개발자는 code3.js와 같이 즉시 호출하는 인라인 익명 함수로 이를 수행하는 경우가 많다.

- code3.js

이를 실행하면 타이머 함수가 counter가 아닌 value를 사용하기 때문에 예상되는 1,2,3을 출력하고
익명 래퍼 함수에 대한 각 호출은 타이머 함수가 종료될 자체 value 매개변수를 가져온다.
이러한 value 매개변수는 변경되지 않으므로 콜백은 예상 값(1,2,3)을 기록한다.
하지만 ES2015의 let 덕분에 훨씬 더 간단하게 해결할 수 있다. var를 let으로 변경하면 된다. code4.js의 코드를 실행하자

- code4.js

역시 예상대로 1,2,3을 출력한다. 작은 변화로 큰 결과를 얻었다. 하지만 어떻게 작동할까?
확실히 함수가 counter를 감쌀까? 어떻게 서로 다른 값을 볼 수 있을까?
익명 함수에 대한 호출이 타이머 함수에 대한 여러 value 매개변수를 생성한 것처럼
code4.js의 루프는 루프에서 생성된 타이머 함수에 대해 루프 반복마다 하나씩 여러 counter 변수를 생성한다.
따라서 각 반복은 자체 counter 변수를 갖는다.
왜 그런지를 이해하려면 자바스크립트에서 변수(와 상수)가 어떻게 작동하는지 더 자세히 살펴봐야 한다. 뒤에 나올 장에서도 이 내용이 도움이 될 것이다.

바인딩: 변수, 상수, 기타 식별자의 작동 방식

이 장의 앞부분에서 const는 범위, 보유할 수 있는 값의 종류 등의 관점에서 let과 동일하게 동작한다는 것을 배웠다.
이는 그럴 만한 이유가 있다. 내부적으로 변수와 상수는 사양에서 바인딩(특히 이 경우 식별자 바인딩)이라고 부르는 동일한 것이다.
이는 식별자와 해당 값에 대한 저장소 간의 연결이다. 예를 들어 다음과 같이 변수를 만들 때,

let x = 42;

x라는 식별자에 대한 바인딩을 만들고 해당 바인딩의 저장소 슬롯에 값 42를 저장한다.
이 경우 변경 가능한 바인딩(값이 변경될 수 있는 바인딩)이다 상수를 만들 때 변경할 수 없는 바인딩(값을 변경할 수 없는 바인딩)을 만든다.
식별자 바인딩에는 이름과 값이 있다.이는 객체 속성과 약간 비슷하지 않은가? 그리고 객체 속성과 마찬가지로 컨테이너에 있으며 환경 객체라고
부를 것이다. 예를 들어, 다음 코드가 실행되는 컨텍스트의 환경 객체는

let a = 1;
const b = 2;

바인딩 =>

        이름: a
        값: 1
        종류: 식별자
        변경 가능 여부: true

        이름: b
        값: 2
        종류: 식별자
        변경 가능 여부: false

중첩된 범위를 처리하기 위해 환경 객체는 체인으로 함께 연결된다. 각 객체에는 "외부" 객체에 대한 링크가 있다.
코드에 현재 환경 객체에 없는 식별자가 필요한 경우 외부 환경 객체에 대한 링크를 따라 찾아 찾는다(전역 변수가 작동하는 방식인 전역 환경을 통해 필요에 따라 반복됨)
외부 환경은 다양한 방식으로 설정된다. 예를 들어 코드 실행이 블록 스코프 식별자가 있는 블록에 들어가면
블록에 대한 환경 객체는 블록을 외부 환경으로 포함하는 코드에 대한 환경 객체를 가져온다.
함수가 호출되면 호출을 위한 환경 객체는 함수가 생성된 환경(함수에 저장되며 사양에 서는 이를 함수의 [[Environment]] 내부 슬롯이라고 함)을 외부 환경으로 가져온다.
이것이 클로저가 작동하는 방식이다.
예를 들어 다음 코드를 보자(전역 스코프에 있다고 가정한다)

- code5.js

함께 따라 가 보자.(바인딩하는게 살짝 호이스팅 느낌)

1. 자바스크립트 엔진은 전역 환경(EnvObject1)을 만들고 바인딩 x,f,example을 여기 추가한다.
2. example 함수를 생성하고 example의 저장된 환경 링크를 현재 환경(전역 확경인 EnvObject1)에 설정하고 example 바인딩의 값을 함수에 설정한다.
3. let x = 1;을 실행한다. x를 1로 설정한다.
4. const f = example(); 줄을 실행한다.
   - EnvObject2라는 새 환경 객체를 생성하고 외부 환경을 example의 저장된 환경(EnvObject1)으로 설정한다.
   - 해당 환경 객체에 y라는 바인딩을 만든다
   - const y = 2; 줄을 실행한다. y를 2로 설정한다.
   - 현재 환경(example 호출을 위한 EnvObject2)을 저장된 환경으로 설정하여 함수를 생성 한다.
   - 호출에서 함수를 반환한다.
   - 함수를 f에 할당한다.
5. 마지막으로 엔진은 f();줄을 실행한다. 함수 f를 호출한다는 것은 다음을 의미한다.
   - 호출에 대한 새 환경 객체(EnvObject3)를 만들고, 해당 외부 환경을 함수의 저장된 환경(EnvObject2, 이전 example 호출에서 가져온 환경)으로 설정하고,
     여기 z 바인딩을 만든다
   - z를 3으로 설정한다.
   - console.log 줄을 실행한다.

console.log 줄에서 엔진은 현재 환경에서 z를 찾지만 y를 찾기 위해 외부 환경(example 호출을 위한 환경)으로 이동해야 하고 x를 찾기 위해 두 단계를 이동해야 한다.
이모든 것이 우리가 ClosuresInLoopsWithLet을 이해하는 데 어떻게 도움이 될까? 그 함수를 다시 살펴보자. 코드 code4.js를 확인

for 루프를 실행할 때 자바스크립트 엔진은 각 루프 반복에 대해 각각 별도의 counter 변수가 있는 새 환경 객체를 생성하므로 각 타이머 콜백은 다른 counter 변수를 감싼다.
다음은 자바스크립트 엔진이 해당 루프로 수행하는 작업이다.
(4,5은 살짝 중복이 아님, 루프에 대한 환경(counter 사용하기 위한)을 하나 더 만든다는 뜻)

1. 호출에 대한 환경 객체를 만든다. CallEnvObject라고 하자.
2. ClosuresInLoopsWithLet 함수(생성된 곳, 이 경우 전역 환경)에 저장된 환경에 대한 CallEnvObject의 외부 환경 참조를 설정한다.
3. for의 초기화 부분에서 let으로 선언된 변수 목록을 기억하여 for 처리를 시작한다. 이경우 counter 하나뿐이지만 더 많이 가질 수 있다.
4. CallEnvObject를 외부 환경으로 사용하여 루프의 초기화 부분에 대한 새 환경 객체를 만들고 값이 1인 counter에 대한 바인딩을 만든다.
5. CallEnvObject를 외부 환경 객체로 사용하여 첫 번째 반복에 대해 새 환경 객체(LoopEnvObject1)를 만든다.
6. 3 단계의 목록을 참조하여 LoopEnvObject1의 카운터에 대한 바인딩을 작성하고 값을 1(초기화 환경 객체의 값)로 설정한다.
7. LoopEnvObject1을 현재 환경 객체로 설정한다.
8. counter <=3 이 참이기 때문에 첫 번째 타이머 함수(timerFunction1 이라고 하자)를 만들어 for의 본문을 실행하고 저장된 환경 객체로 LoopEnvObject1에 대한 참조를 제공한다
9. timerFunction1에 대한 참조를 전달하는 setTimeout을 호출한다.

이 시점에서 자바스크립트 엔진은 다음 루프 반복을 위한 준비가 되었다.

10. CallEnvObject를 외부 환경으로 사용하여 새로운 환경 객체(LoopEnvObject2)를 생성한다.
11. 3단계 바인딩 목록을 사용하여 LoopEnvObject2에 카운터에 대한 바인딩을 만들고 해당 값을 LoopEnvObject1에 있는 카운터의 현재 값(이 경우 1)으로 설정한다.
12. LoopEnvObject2를 현재 환경 객체로 설정한다.
13. for 루프의 "증가" 부분(++counter)을 수행한다. 증가하는 counter는 현재 환경 객체인 LoopEnvObject2에 있는 카운터다. 값이 1이므로 2가 된다.
14. for 루프를 계속한다. 조건이 참이므로 두 번째 타이머 함수(timerFunction2)를 생성하여 루프 본문을 실행하고 LoopEnvObject2에 대한 참조를 제공하여 그 안의 정보를 감싼다.
15. timerFunction2에 대한 참조를 전달하는 setTimeout을 호출한다.

보다시피 두 타이머 함수는 counter의 다른 사본을 다른 환경 객체에서 감싼다.
첫 번째는 여전히 counter = 1이다. 두 분째 것은 counter = 2이다.

타이머 함수가 타이머에 의해 호출될 때 각각 별도의 환경 객체를 사용하고 각각 자체 counter 복사본을 사용하기 때문에
동일한 환경 객체와 변수를 모두 공유하는 var의 값인 4,4,4 대신 1,2,3이 표시 된다.
요컨대, 루프의 블록 스코프 매커니즘은 ES5 솔루션의 익명 함수가 수행한 작업을 정확히 수행했다.
각 타이머 함수에 바인딩의 자체 복사본으로 감쌀 수 있는 다른 환경 객체를 제공했다(let 솔루션의 counter, ES5의 값 해결책).
그러나 별도의 함수와 함수 호출없이 더 효율적으로 수행했다.
물론 때로는 이전 동작을 원한다. 이경우 루프 밖에 변수를 선언하자(이것은 물론 var가 한 일이다.).
루프에 대해 방금 배운 동작의 유일한 부분은 하나의 환경 객체에서 다음 객체로 바인딩의 값을 복사하고 for의 초기화 부분에서 생성된 변수를 추적하는 부분이다.
그러나 블록이 자체 환경 객체를 얻는다는 사실은 for 루프에만 국한되지 않으며,
무엇보다도 while과 do-while 루프가 자체 환경 객체를 얻는 블록의 이점을 얻을 수 있음을 의미한다.
방법을 살펴보겠다.

whilte과 do-while 루프

while과 do-while은 블록이 자체 환경 객체를 가진다는 사실에서 오는 이점도 있다.
for의 초기화 표현식이 없기 때문에 거기에 선언된 바인딩 값을 복사하는 작업을 수행하지 않지만
각 루프 반복과 연관된 블록은 여전히 자체 환경을 갖는다. 실제로 작동하는지 보자

- code6.js

성능 영향
루프에서 블록 스코프가 작동하는 방식에 대해 생각하면 다음과 같이 생각할 수 있다.
"잠깐, 루프에서 블록 변수를 사용하고 이를 보유하고 체인을 설정하고 (for 루프의 경우)
복사할 새 환경 객체를 만들어야 하고 어딘가에서 어딘가로 반복 바인딩 값을 복사해야 한다면 루프 속도가 느려지지 않을까?
이에 대한 두 가지 답변이 있다.

1. 아마 상관하지 않을 것이다. 성급한 최적화는 성급하다는 것을 기억하자. 실제 성능 문제가 있어 해결해야 하는 경우에 걱정하자.
2. 그렇기도 하고 아니기도 하다. 자바스크립트 엔진이 차이를 최적하지 않았고 차이를 최적화할 수 없는 경우(루프의 클로저 예 포함)가 있다면 확실히 더 많은 오버 헤드가 발생한다.
   다른 경우에는 클로저를 생성하지 않거나 엔진이 클로저가 루프 반복 변수를 사용하지 않는다고 결정할 수 있다면 차이를 최적화할 수 있다.
   최신 엔진은 많은 최적화를 수행한다. ES2015의 let이 새로워졌을 때 크롬의 v8 엔진은 var를 사용한 경우보다 루프 변수에 let을 사용하면 for 루프가 현저히 느렸다.
   v8의 엔지니어가 이를 최적화하는 방법을 찾았기 때문에 (클로저가 생성되지 않는 경우 등) 속도 차이는 사라졌다.

루프에 실제 문제가 발생하고 변수의 별도 사본이 있는 것이 중요하지 않은 경우, 둘러싼 범위로 이동하자.

let n;
for(n = 0; n < aReallyReallyBigNumber; ++n){
// .
}

또는 해당 범위에서 원하지 않는 경우 전체 루프를 익명 블록으로 래핑하고 해당 블록에서 변수를 선언한다.

{
let n;
for (n = 0; n < aReallyReallyBigNumber; ++n) {
// .
}
}

루프 블록에서 const

const에 대한 이전 절에서 변수(목록) 중 하나가 실제로 변경되지 않은 간단한 div 업데이트 루프를 보았고
let과 const를 코드에 (식별자를 제거하지 않고) 어떻게 적용할지 생각해 보라고 요청했다

- code7.js

그 당시에는 요소와 텍스트를 for 루프 블록으로 옮기는 것을 생각하지 않았을 수도 있고,
그렇게 했다면 그것들을 const 선언이 아닌 let으로 남겨 두었을 수도 있다.
그러나 블록 내의 값은 절대 변경되지 않으며, 물론 각 블록은 자체 사본을 가져오므로
범위 내에서 상수이며 const를 선언하여 수정하는 것이 아니라 사용하려는 의도를 표시할 수 있따.
변경하지 않는다는 이유만으로 const를 선언할 필요가 없다.
변경 여부는 스타일의 문제이며 팀이 논의하고 동의해야 하는 사항이다(const를 사용하거나, const를 사용하지 않거나, 개별 스타일에 맡겨라).
개발 중에 사용하면 실용적인 이점이 있다(팀원이 const로 선언한 것을 변경하려고 하면 초기 오류가 발생한다. 그런 다음 의도적으로 선언을 변경하거나 해당 상수의 값을 변경하지 않는다)
(나중에) 오류를 찾을 수 있는 전체 테스트 스위트를 사용한다.

for-in 루프에서 const
네 부분(초기화, 종료조건, 증감식, 본문)이 있는 일반적인 for 루프 외에도 자바스크립트에는 for-in, for-of, for-await-of 같은 다른 유형의 for 루프가 있다
일반적인 for-in에 대해 간단히 살펴보자

- code8.js

ES2015+에서 작성하려는 경우 key에 let이나 const를 사용할 수 있을까?
둘 중 하나를 사용할 수 있다. 어휘 선언이 있는 for-in루프는 while 처럼 각 루프 반복에 대해 별도의 환경 객체를 얻는다.
루프 본문의 코드는 키를 변경하지 않으므로 원하는 경우 const가 될 수 있다.

- code9.js
