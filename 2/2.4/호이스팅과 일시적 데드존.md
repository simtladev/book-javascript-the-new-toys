var 선언이 호이스팅된다는 것은 잘 알려져 있다. var를 사용하면 변수를 선언하기 전에 사용할 수 있다.

- code1.js

example을 실행하면 다음이 출력된다.

undefined
42

변수가 선언되기 전에 신나게 사용했지만 var 선언이 함수의 맨 위로 이동한 것처럼 동작한다.
그리고 선언만 이동하고 그것에 연결된 초기화(var answer = 67의 = 67 부분)는 아니다.
이는 example 함수를 실행할 때 자바스크립트 엔진이 단계별 코드 실행을 시작하기 전에 var 선언을 처리하고 필요한 변수를
생성하는 함수를 스캔하기 때문에 발생한다. 함수의 맨 위에 선언을 "호이스트"한다(끌어올린다). 그렇게 할 때 undefined 기본값으로 선언한 변수를 초기화한다.
그러나 다시 말하지만, 코드의 명백한 의도와 실제 효과는 동기화되지 않았으므로 여기에 버그가 있음을 의미할 수 있다.
첫 번째 줄은 포함 범위(아마도 전역일 수도 있음)에 있는 응답 변수에 할당하려고 하지만 대신 로컬을 사용하는 것 같다.
또한 작성자가 answer가 생성될 때 값이 67로 시작되도록 의도한 것처럼 보인다.
let과 const를 사용하면 코드의 단계별 실행에서 선언이 처리될 때까지 변수를 사용할 수 없다.

- code2.js

겉보기에는 let 선언을 var 선언처럼 함수의 맨 위로 올라가지 않는다. 하지만 이것은 흔히들 하는 오해다.
let과 const도 호이스팅된다. 단지 다르게 호이스팅될 뿐이다.

코드가 포함 범위의 answer에 할당하려고 시도했을 수 있다는 사실을 고려하자. 해당 시나리오를 살펴보겠다.

- code3.js

마지막에 내부의 let answer까지 answer가 존재하지 않는다면,
함수의 시작 부분에서 answer = 42; 라인이 외부 answer에 할당되어야 하지 않는가?
그렇게 설계되었을 수도 있다. 그렇다. 하지만 얼마나 혼란스러울까?
범위의 초기에는 식별자를 사용하지만 범위의 후반에는 버그를 요구하는 것이다
대신, let과 const는 임시 데드존이라는 개념을 사용한다.
코드 실행 내에서 식별자를 전혀 사용할 수 없는 기간인 TDZ는 포함된 범위의 엔트리를 참조하는 데도 사용되지 않는다.
var와 마찬가지로 자바스크립트 엔진은 코드의 단계별 실행을 시작하기 전에 let과 const선언에 대한 코드를 살펴보고 처리한다.
그러나 answer에 접근할 수 있도록 하고 정의되지 않은 값을 제공하는 대신 엔진은 answer를 "아직 초기화되지 않음"으로 표시한다

- code4.js

TDZ는 코드 실행이 선언이 나타나는 범위에 들어갈 때 시작되고 선언이 실행될 떄까지 계속된다(초기화가 붙어 있는 상태로).
이 예에서 내부 answer는 notInitializedYet(TDZ가 시작되는 곳)의 시작 부분에 예약되고 선언이 있는 곳(TDZ가 끝나는 곳)에서 초기화된다.
따라서 let과 const는 역시 호이스트되고 var와는 다르게 호이스트된다.
TDZ는 공간적(위치 관련)이 아니라 시간적(시간 관련)이라는 점을 이해하는 것이 중요하다. 식별자를 사용할 수 없는 범위의 맨 위에 있는 영역이 아니다.
식별자를 사용할 수 없는 기간이다.

- code5.js

TDZ가 공간에 관한 것이라면 value는 temporalExample의 맨 위의 코드 블록에서 사용될 수 없고,
코드도 작동하지 않아야 한다. 하지만 TDZ는 시간에 관한 것이며 F가 value를 사용하기 전에 선언이 실행되었으므로 문제가 없다.
해당 함수의 마지막 두 줄을 교환하면, 즉 f()를 let value = 4; 위로 옮기면 f가 초기화되기 전에 값을 사용하려고 하기 때문에 실패한다(시도해 보자!)
TDZ는 함수에 적용되는 것과 마찬가지로 브록에도 적용된다.

- code6.js

블록 내부의 첫번째 줄에는 p를 사용할 수 없다. 왜냐하면 함수에서 선언되었더라도 p 식별자의 소유권을 갖는 블록 내부에 섀도잉 선언이 있기 때문이다.
따라서 식별자는 let 선언이 실행된 후에만 새로운 내부 p를 참조할 수 있다. 이것은 코드가 어떤 p를 사용하고 있는지에 대한 혼동을 방지한다.

요약:
var, let, const는 모두 호이스팅이 된다. 하지만 방식이 조금 다르다.
var는 호이스팅시에 undefined로 초기화 되지만, let, const는 해당 라인에 도착해야 초기화가 된다.
그래서 그 중간사이에 선언되어있는 변수를 사용할 시에 TDZ(Cannot access before initialization) error가 발생한다.
밖에 블록에서 선언된 변수와, 안에 블록에서 선언된 변수의 이름이 같을 시 안에 블록에 선언된 변수가 우선권을 갖는것을 섀도잉이라고 한다.
